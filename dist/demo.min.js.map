{"version":3,"file":"demo.min.js","sources":["../src/tools.js","../src/config.js","../src/enum.js","../src/index.js","../src/polyfill.js","../examples/index.js"],"sourcesContent":["export function merge (bufferList, length) {\n  const data = new Float32Array(length);\n\n  for (let i = 0, offset = 0; i < bufferList.length; offset += bufferList[i].length, i += 1) {\n    data.set(bufferList[i], offset);\n  }\n\n  return data;\n}\n\nexport function compress (buffer, inputSampleRate, outputSampleRate) {\n  if (inputSampleRate < outputSampleRate) {\n    throw new Error('Invalid parameter: \"inputSampleRate\" must be greater than \"outputSampleRate\"');\n  }\n\n  const bufferLength = buffer.length;\n  inputSampleRate += 0.0;\n  outputSampleRate += 0.0;\n  const compression = inputSampleRate / outputSampleRate;\n  const outLength = Math.ceil(bufferLength * outputSampleRate / inputSampleRate);\n  const data = new Float32Array(outLength);\n\n  let s = 0;\n  for (let i = 0; i < outLength; i += 1) {\n    data[i] = buffer[Math.floor(s)];\n    s += compression;\n  }\n\n  return data;\n}\n\nexport function encodeToPCM (bytes, sampleBits) {\n  if ([8, 16].indexOf(sampleBits) === -1) {\n    throw new Error('Invalid parameter: \"sampleBits\" must be 8 or 16');\n  }\n\n  const dataLength = bytes.length * (sampleBits / 8);\n  const buffer = new ArrayBuffer(dataLength);\n  const view = new DataView(buffer);\n\n  for (let i = 0, offset = 0; i < bytes.length; i += 1, offset += sampleBits / 8) {\n    const s = Math.max(-1, Math.min(1, bytes[i]));\n    const val = s < 0 ? s * 0x8000 : s * 0x7fff;\n    if (sampleBits === 8) {\n      view.setInt8(offset, parseInt(255 / (65535 / (val + 32768)), 10), true);\n    } else {\n      view.setInt16(offset, val, true);\n    }\n  }\n\n  return view.buffer;\n}\n\nexport function encodeToWAV (bytes, sampleBits, sampleRate) {\n  if ([8, 16].indexOf(sampleBits) === -1) {\n    throw new Error('Invalid parameter: \"sampleBits\" must be 8 or 16');\n  }\n\n  const dataLength = bytes.length * (sampleBits / 8);\n  const buffer = new ArrayBuffer(44 + dataLength);\n  const view = new DataView(buffer);\n  const channelCount = 1;\n  let offset = 0;\n\n  const writeString = (str) => {\n    for (let i = 0; i < str.length; i += 1) {\n      view.setUint8(offset + i, str.charCodeAt(i));\n    }\n  };\n\n  // WAV HEAD\n  writeString('RIFF');\n  offset += 4;\n  view.setUint32(offset, 36 + dataLength, true);\n  offset += 4;\n  writeString('WAVE');\n  offset += 4;\n  writeString('fmt ');\n  offset += 4;\n  view.setUint32(offset, 16, true);\n  offset += 4;\n  view.setUint16(offset, 1, true);\n  offset += 2;\n  view.setUint16(offset, channelCount, true);\n  offset += 2;\n  view.setUint32(offset, sampleRate, true);\n  offset += 4;\n  view.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), true);\n  offset += 4;\n  view.setUint16(offset, channelCount * (sampleBits / 8), true);\n  offset += 2;\n  view.setUint16(offset, sampleBits, true);\n  offset += 2;\n  writeString('data');\n  offset += 4;\n  view.setUint32(offset, dataLength, true);\n  offset += 4;\n\n  // write PCM\n  for (let i = 0; i < bytes.length; i += 1, offset += sampleBits / 8) {\n    const s = Math.max(-1, Math.min(1, bytes[i]));\n    const val = s < 0 ? s * 0x8000 : s * 0x7fff;\n\n    if (sampleBits === 8) {\n      view.setInt8(offset, parseInt(255 / (65535 / (val + 32768)), 10), true);\n    } else {\n      view.setInt16(offset, val, true);\n    }\n  }\n\n  return new Blob([view], { type: 'audio/wav' });\n}\n","export default {\n  recordable: true,\n  sampleRate: 16000,\n  sampleBits: 16,\n  bufferSize: 16384,\n};\n","export const RECORDER_STATE = {\n  READY: 0,\n  RECORDING: 1,\n};\n\nexport const ENCODE_TYPE = {\n  RAW: 'raw',\n  PCM: 'pcm',\n  WAV: 'wav',\n};\n","import {\n  merge,\n  compress,\n  encodeToPCM,\n  encodeToWAV,\n} from './tools';\nimport environmentCheck from './polyfill';\nimport DEFAULT_CONFIG from './config';\nimport { RECORDER_STATE, ENCODE_TYPE } from './enum';\n\nclass Recorderx {\n  state = RECORDER_STATE.READY\n\n  ctx = new (window.AudioContext || window.webkitAudioContext)()\n\n  sampleRate = DEFAULT_CONFIG.sampleRate\n\n  sampleBits = DEFAULT_CONFIG.sampleBits\n\n  recordable = DEFAULT_CONFIG.recordable\n\n  recorder = null\n\n  source = null\n\n  stream = null\n\n  buffer = []\n\n  bufferSize = 0\n\n  constructor (\n    {\n      recordable = DEFAULT_CONFIG.recordable,\n      bufferSize = DEFAULT_CONFIG.bufferSize,\n      sampleRate = DEFAULT_CONFIG.sampleRate,\n      sampleBits = DEFAULT_CONFIG.sampleBits,\n    } = DEFAULT_CONFIG,\n  ) {\n    const { ctx } = this;\n    const creator = ctx.createScriptProcessor || ctx.createJavaScriptNode;\n    this.recorder = creator.call(ctx, bufferSize, 1, 1);\n    this.recordable = recordable;\n    this.sampleRate = sampleRate;\n    this.sampleBits = sampleBits;\n  }\n\n  start (audioprocessCallback) {\n    this.clear();\n\n    return new Promise((resolve, reject) => {\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then((stream) => {\n          const { recorder } = this;\n          const source = this.ctx.createMediaStreamSource(stream);\n\n          this.stream = stream;\n          this.source = source;\n\n          recorder.onaudioprocess = (e) => {\n            const channelData = e.inputBuffer.getChannelData(0);\n\n            if (this.recordable) {\n              this.buffer.push(channelData.slice(0));\n              this.bufferSize += channelData.length;\n            }\n\n            if (typeof audioprocessCallback === 'function') {\n              audioprocessCallback(channelData);\n            }\n          };\n\n          source.connect(recorder);\n          recorder.connect(this.ctx.destination);\n\n          this.state = RECORDER_STATE.RECORDING;\n\n          resolve(stream);\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    });\n  }\n\n  pause () {\n    this.stream.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.recorder.disconnect();\n    this.source.disconnect();\n    // this.ctx.suspend();\n    this.state = RECORDER_STATE.READY;\n  }\n\n  clear () {\n    this.buffer = [];\n    this.bufferSize = 0;\n  }\n\n  getRecord ({\n    encodeTo = ENCODE_TYPE.RAW,\n    compressible = false,\n  } = {\n    encodeTo: ENCODE_TYPE.RAW,\n    compressible: false,\n  }) {\n    if (this.recordable) {\n      let buffer = merge(this.buffer, this.bufferSize);\n\n      const inputSampleRate = this.ctx.sampleRate;\n      compressible = compressible && (this.sampleRate < inputSampleRate);\n      const outSampleRate = compressible ? this.sampleRate : inputSampleRate;\n\n      if (compressible) {\n        buffer = compress(buffer, inputSampleRate, outSampleRate);\n      }\n\n      switch (encodeTo) {\n        case ENCODE_TYPE.RAW:\n          return buffer;\n        case ENCODE_TYPE.PCM:\n          return encodeToPCM(buffer, this.sampleBits);\n        case ENCODE_TYPE.WAV:\n          return encodeToWAV(buffer, this.sampleBits, outSampleRate);\n        default:\n          throw new Error('Invalid parameter: \"encodeTo\" must be ENCODE_TYPE');\n      }\n    }\n\n    throw new Error('Configuration error: \"recordable\" must be set to true');\n  }\n}\n\nenvironmentCheck();\n\nexport const audioTools = {\n  merge,\n  compress,\n  encodeToPCM,\n  encodeToWAV,\n};\nexport { RECORDER_STATE, ENCODE_TYPE };\nexport default Recorderx;\n","export default function environmentCheck () {\n  if (window === undefined || navigator === undefined) {\n    return;\n  }\n\n  if (navigator.mediaDevices === undefined) {\n    navigator.mediaDevices = {};\n  }\n\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      const getUserMedia = navigator.getUserMedia\n        || navigator.webkitGetUserMedia\n        || navigator.mozGetUserMedia\n        || navigator.msGetUserMedia;\n\n      if (!getUserMedia) {\n        return Promise.reject(\n          new Error('getUserMedia is not implemented in this environment'),\n        );\n      }\n\n      return new Promise((resolve, reject) => {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n}\n","import Recorderx, { RECORDER_STATE, ENCODE_TYPE } from '../src/index';\n\nconst btnStart = document.getElementById('btn-start');\nconst btnPause = document.getElementById('btn-pause');\nconst btnClear = document.getElementById('btn-clear');\nconst dlog = document.getElementById('log');\nconst audio = document.getElementById('audio');\n\nfunction pushLog (log, error = '') {\n  const xlog = `<span style=\"margin-right:8px\">\n           ${(new Date()).toLocaleString()}:\n         </span>\n         <span style=\"color:${error ? 'red' : 'blue'}\">\n           ${log} ${error}\n         </span>`;\n  const dl = document.createElement('div');\n  dl.innerHTML = xlog;\n  dlog.appendChild(dl);\n}\n\nlet rc;\n\nbtnStart.addEventListener('click', () => {\n  if (!rc) {\n    rc = new Recorderx({\n      recordable: true,\n      sampleRate: 16000,\n    });\n  }\n  if (rc.state === RECORDER_STATE.READY) {\n    rc.start()\n      .then(() => {\n        pushLog('start recording');\n      })\n      .catch((error) => {\n        pushLog('Recording failed.', error);\n      });\n  }\n});\n\nbtnPause.addEventListener('click', () => {\n  if (rc && rc.state === RECORDER_STATE.RECORDING) {\n    rc.pause();\n    audio.src = URL.createObjectURL(rc.getRecord({\n      encodeTo: ENCODE_TYPE.WAV,\n      compressible: true,\n    }));\n    pushLog('pause recording');\n  }\n});\n\nbtnClear.addEventListener('click', () => {\n  rc.clear();\n});\n"],"names":["encodeToWAV","bytes","sampleBits","sampleRate","indexOf","Error","writeString","str","i","length","view","setUint8","offset","charCodeAt","dataLength","buffer","ArrayBuffer","DataView","setUint32","setUint16","s","Math","max","min","val","setInt8","parseInt","setInt16","Blob","type","recordable","bufferSize","RECORDER_STATE","READY","RECORDING","ENCODE_TYPE","Recorderx","DEFAULT_CONFIG","window","AudioContext","webkitAudioContext","ctx","this","creator","createScriptProcessor","createJavaScriptNode","recorder","call","audioprocessCallback","clear","Promise","resolve","reject","navigator","mediaDevices","getUserMedia","audio","then","stream","_this","source","createMediaStreamSource","onaudioprocess","e","channelData","inputBuffer","getChannelData","push","slice","connect","destination","state","error","getAudioTracks","forEach","track","stop","disconnect","encodeTo","compressible","bufferList","data","Float32Array","set","merge","inputSampleRate","outSampleRate","outputSampleRate","bufferLength","compression","outLength","ceil","floor","compress","encodeToPCM","undefined","constraints","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","rc","btnStart","document","getElementById","btnPause","btnClear","dlog","pushLog","log","xlog","Date","toLocaleString","dl","createElement","innerHTML","appendChild","addEventListener","start","pause","src","URL","createObjectURL","getRecord"],"mappings":"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"}